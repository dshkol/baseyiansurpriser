% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/surprise-core.R
\name{compute_surprise}
\alias{compute_surprise}
\title{Compute Per-Region Surprise}
\usage{
compute_surprise(
  model_space,
  observed,
  expected = NULL,
  return_signed = TRUE,
  return_posteriors = FALSE,
  return_contributions = FALSE,
  normalize_posterior = TRUE,
  ...
)
}
\arguments{
\item{model_space}{A \code{bs_model_space} object}

\item{observed}{Numeric vector of observed values (one per region)}

\item{expected}{Numeric vector of expected values (optional, for signed surprise)}

\item{return_signed}{Logical; compute signed surprise?}

\item{return_posteriors}{Logical; return per-region posteriors?}

\item{return_contributions}{Logical; return per-model contributions?}

\item{normalize_posterior}{Logical; if TRUE (default), normalizes posteriors
to sum to 1. If FALSE, uses unnormalized posteriors (P(D|M) * P(M)) which
matches the original Correll & Heer (2017) JavaScript implementation.}

\item{...}{Additional arguments passed to likelihood functions}
}
\value{
A \code{bs_surprise} object
}
\description{
Computes the surprise (KL-divergence) for each observation/region,
measuring how much each data point updates beliefs about the model space.
}
\details{
For each region i, computes:
\enumerate{
\item The posterior P(M|D_i) given just that region's data
\item The KL-divergence from prior to posterior (surprise)
\item Optionally, the sign based on deviation direction
}

When \code{normalize_posterior = FALSE}, the function matches the original paper's
JavaScript implementation which uses unnormalized posteriors in the KL
computation. This is mathematically unconventional but reproduces the
published results exactly.
}
